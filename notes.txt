cat /etc/os-release
cat /proc/version
cat /etc/debian-version
dpkg -S `which ld`
cat /proc/cpuinfo

advanates of little endian: 
1. casts are noop since address of 1(char),2(short/half),4(int/float/word),8(longint/double/doubleword/size/addr) byte int would be same
2. for 8 bit systems or for big integers/big integers: addition and subtraction can be pipelined or parallelized since lsb needs to
perform addition/subtraction before msb


alignment:https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/ 
std::has_unique_object_representation
alignas
std::alignment_of
__attribute__((packed))


standardlayout object
p4 sync -N ...
info vtbl variable
sb -nosplash -nodesktop -r "sfnew;bdclose all"

exception handling: LSDA, CFI, personality function, unwind.h, setjmp, longjmp,
goto
-fPIC vs load time relocation
static library vs shared library. 
shared library can be statically linked (-fPIC) vs dynamic linked (load time relocation)
dynamically loaded
disadvantate of dynamicalled linked shared library:https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/
https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/
1. non-sharable text section, ram usage increase since each exe that loads
library needs separate copy 2. text section needs writable, security 3. load time increases

can we relink shared library online?
.got: global offset table
.bss: block started by symbol
plt: procedure location table
https://reverseengineering.stackexchange.com/questions/1992/what-is-plt-got


info proc mapping
info sharedlibrary
https://reverseengineering.stackexchange.com/questions/6657/why-does-ldd-and-gdb-info-sharedlibrary-show-a-different-library-base-addr
